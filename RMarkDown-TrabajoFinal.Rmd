---
title: "Data Science Trabajo Final"
author: "Lenin Valles | Gianpaul Custodio | Julio Fuerte"
date: "2023-11-22"
output:
  html_document:
    toc: yes
    toc_depth: 2
lang: es-ES
---

#Seminario Internacional en Herramientas y Técnicas de Detección de Ciberamenazas Actividad Evaluable 3

## Análisis de Logs de Servidor Usando R


***Proyecto de Investigación   -->  ***
[Repositorio del Proyecto](https://github.com/leninvalles/ciencia_datos_laboratorio3.git)

#******************************************************************************#
#                                                                              #
#        Lab 3 - Análisis de logs de servidor usando R (Parte II)              #
#                                                                              #
#           Gianpaul Custodio | Julio Fuerte | Lenin Valles                    #
#                                                                              #
#******************************************************************************#
#
#
#Preguntas de Investigación
#
#Librerias a utilizar
require(rvest)
require(urltools)
require(curl)
require(httr)
require(plyr)
require(plotly)
require(xml2)
require(XML)
require(dplyr)
#1. Descomprimir el fichero comprimido que contiene los registros del servidor, 
#y a partir de los datos extraídos, cargar en data frame los registros con las
#peticiones servidas.
#
#
#Procedemos a realizar la importación del archivo .csv
library(readr)
epa_http <- read_table("epa-http.csv", col_names = FALSE)
View(epa_http)

#Verificamos el tipo de dato referente a la columna de fecha y hora
class(epa_http$X2)

#Procedemos a formatear el nombre de las columnas
colnames(epa_http) <- c("IP", "Tiempo", "Tipo", "URL", "Protocolo", "Codigo", "Bytes")

#Corroboramos la correcta aplicación de los cambios
class(epa_http$Tiempo)

#Realizamos el formateo el valor "-" por "0"
epa_http$Bytes <- replace(epa_http$Bytes, epa_http$Bytes == "-", 0)

#Realizamos el formateo del tipo de valor de la columna Bytes a numérico
epa_http$Bytes <- as.numeric(epa_http$Bytes)

#Procedemos al formateo del tipo de valor de la columna Codigo a factor
epa_http$Codigo <- as.factor(epa_http$Codigo)

#Procederemos a Formatear el tipo de valor de la colunma Tiempo a fecha
epa_http$Tiempo <- as.POSIXct(epa_http$Tiempo, format = "[%d:%H:%M:%S]",tz="CET")

#
#
#2. Identificar el número único de usuarios que han interactuado directamente con
#el servidor de forma segregada según si los usuarios han tenido algún tipo de
#error en las distintas peticiones ofrecidas por el servidor.
#
#
#Aplicamos el filtro para los valores de Codigo. El filtro es aplicado teniendo 
#en consideración solo respuestas 200, 302 y 304. Las respuestas 400,403,404,
#500 y 501 no se toman en cuenta porque indica que el servidor no puede procesar
#la solicitud, por lo cual se percibe como un error del cliente (usuario).
filtro3 <- filter(epa_http, Codigo == 200 | Codigo == 302 | Codigo == 304)
View(filtro3)

#Comprobamos si se han aplicado correctamente los filtros.
unique(filtro3$Codigo)
#
#
#3. Analizar los distintos tipos de peticiones HTTP (GET, POST, PUT, DELETE)
#gestionadas por el servidor, identificando la frecuencia de cada una de estas.
#Repetir el análisis, esta vez filtrando previamente aquellas peticiones
#correspondientes a recursos ofrecidos de tipo imagen.
#
#
#Utilizando el método Table organizamos los métodos GET, HEAD y POST, midiendo 
#su frecuencia en relación a la columna "Tipo"
filtrotipo <- table(epa_http$Tipo)
#Visualizar el filtro
View(filtrotipo)
#Comprobamos si se han aplicado correctamente los filtros.
unique(filtrotipo$Codigo)
#
#
#4. Generar al menos 2 gráficos distintos que permitan visualizar alguna
#característica relevante de los datos analizados. Estos deberán representar por
#lo menos 1 o 2 variables diferentes del data frame. Describid el gráfico e 
#indicad cualquier observación destacable que se pueda apreciar gracias a la
#representación gráfica.
#
#
# Elaboramos el gráfico de Cantidad de Peticiones HTTP
dato <-  data.frame(filtrotipo)
View(dato)
#Elaboracion de grafico por cantidad de peticiones
barplot(dato$Freq, names.arg = dato$Var1, ylab = "Frecuencia", xlab = "Metodo HTTP", main = "Cantidad de Peticiones HTTP")
#
#
#5. Generar un gráfico que permita visualizar el número de peticiones servidas a
#lo largo del tiempo.
#
#
ggplot2::ggplot(data=epa_http)+geom_histogram(aes(x = TIME_STAMP), binwidth= 500, col='black', fill='green', alpha=0.4)+ggtitle ('Peticiones a lo Largo del Tiempo')

#6. Utilizando un algoritmo de aprendizaje no supervisado, realizad un análisis de
#clústering con k-means para los datos del servidor.

library(dplyr)
library(mltools)  
library(data.table)
library(readr)
library(mltools)
View(epa_http)
epa_http_one_hot <- one_hot(as.data.table(epa_http), sparsifyNAs = TRUE)
#resultado <- kmeans(epa_http2, centers = 2)
epa_http2 <- epa_http_one_hot
resultado <- kmeans(na.omit(epa_http2), centers = 2)

epa_http2$IP <- NULL
epa_http2$Tipo <- NULL
epa_http2$URL <- NULL
epa_http2$Tiempo <- NULL
epa_http2$Protocolo <- NULL

#df_sin_na <- subset(df, !is.na(x) & !is.na(y))
epa_http2 <- epa_http2[complete.cases(epa_http2), ]
plot(epa_http_one_hot, col=resultado$cluster)


#7. Representad visualmente en gráficos de tipo scatter plot el resultado de
#vuestros clústering y interpretad el resultado obtenido

{r pregunta, echo=FALSE, message=FALSE, warning=FALSE}
epa_http2$cluster <- as.character(resultado$cluster)

ggplot2::ggplot() + geom_point(data = epa_http2$cluster, mapping = aes(x = BYTES ,y = TIME_STAMP, colour = cluster))


